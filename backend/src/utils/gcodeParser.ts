/**
 * G-code parser for extracting consumption data from slicer-generated G-code files
 */

export interface GCodeMetadata {
  slicer: string;
  usedFilamentM: number | null;
  usedFilamentG: number | null;
  printTime: string | null;
  materialType: string | null;
  color: string | null;
  modelName: string | null;
  layerCount: number | null;
  maxZHeight: number | null;
}

export interface ParsedGCode {
  success: boolean;
  metadata: GCodeMetadata;
  error?: string;
}

/**
 * Parse Anycubic Slicer Next G-code format
 */
function parseAnycubicSlicerNext(content: string): ParsedGCode {
  const metadata: GCodeMetadata = {
    slicer: 'Anycubic Slicer Next',
    usedFilamentM: null,
    usedFilamentG: null,
    printTime: null,
    materialType: null,
    color: null,
    modelName: null,
    layerCount: null,
    maxZHeight: null,
  };

  try {
    // Extract used_filament (in meters) - handle both = and : formats
    const usedFilamentMatch = content.match(/used_filament\s*[=:]\s*([\d.]+)/i);
    if (usedFilamentMatch) {
      metadata.usedFilamentM = parseFloat(usedFilamentMatch[1]);
    }

    // Extract filament_density (g/cm³) - handle both = and : formats
    const densityMatch = content.match(/filament_density\s*[=:]\s*([\d.]+)/i);
    const density = densityMatch ? parseFloat(densityMatch[1]) : null;

    // Extract filament_diameter (mm) - handle both = and : formats
    const diameterMatch = content.match(/filament_diameter\s*[=:]\s*([\d.]+)/i);
    const diameter = diameterMatch ? parseFloat(diameterMatch[1]) : null;

    // Calculate weight in grams if we have all required data
    if (metadata.usedFilamentM && density && diameter) {
      // Convert diameter from mm to cm, then calculate volume in cm³
      const radiusCm = (diameter / 10) / 2; // mm to cm, then radius
      const volumeCm3 = Math.PI * radiusCm * radiusCm * (metadata.usedFilamentM * 100); // meters to cm
      metadata.usedFilamentG = volumeCm3 * density;
    }

    // Extract print_time (limit to 100 chars to prevent ReDoS)
    const printTimeMatch = content.match(/print_time\s*=\s*([^\n]{0,100})/i);
    if (printTimeMatch) {
      metadata.printTime = printTimeMatch[1].trim();
    }

    // Extract material_type from ams_info
    // Use bounded quantifier to prevent ReDoS (limit to 5000 chars)
    const amsInfoMatch = content.match(/ams_info\s*=\s*begin([\s\S]{0,5000}?)ams_info\s*=\s*end/i);
    if (amsInfoMatch) {
      const amsInfo = amsInfoMatch[1];
      
      // Extract material_type
      const materialMatch = amsInfo.match(/"material_type":"([^"]+)"/i);
      if (materialMatch) {
        metadata.materialType = materialMatch[1];
      }

      // Extract paint_color (RGB array)
      const colorMatch = amsInfo.match(/"paint_color":\[(\d+),(\d+),(\d+)\]/i);
      if (colorMatch) {
        const r = parseInt(colorMatch[1]);
        const g = parseInt(colorMatch[2]);
        const b = parseInt(colorMatch[3]);
        // Convert RGB to hex
        metadata.color = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`.toUpperCase();
      }
    }

    // Extract model name from source_info
    // Use a safer regex with bounded quantifier to prevent ReDoS
    const sourceInfoMatch = content.match(/source_info:\s*(\{[^{}]{0,10000}\})/i);
    if (sourceInfoMatch) {
      try {
        const sourceInfo = JSON.parse(sourceInfoMatch[1]);
        if (sourceInfo.models && sourceInfo.models.length > 0) {
          metadata.modelName = sourceInfo.models[0].name || null;
        }
      } catch (e) {
        // JSON parse failed, try simple regex
        const nameMatch = sourceInfoMatch[1].match(/"name":"([^"]+)"/i);
        if (nameMatch) {
          metadata.modelName = nameMatch[1];
        }
      }
    }

    // Extract total layer number
    const layerMatch = content.match(/total layer number:\s*(\d+)/i);
    if (layerMatch) {
      metadata.layerCount = parseInt(layerMatch[1]);
    }

    // Extract max_z_height
    const maxZMatch = content.match(/max_z_height:\s*([\d.]+)/i);
    if (maxZMatch) {
      metadata.maxZHeight = parseFloat(maxZMatch[1]);
    }

    return {
      success: true,
      metadata,
    };
  } catch (error: any) {
    return {
      success: false,
      metadata,
      error: error.message || 'Failed to parse G-code',
    };
  }
}

/**
 * Detect slicer type from G-code content
 */
function detectSlicer(content: string): string | null {
  // Check for Anycubic Slicer Next
  if (content.includes('AnycubicSlicerNext') || content.includes('generated by AnycubicSlicerNext')) {
    return 'AnycubicSlicerNext';
  }
  
  // Add more slicer detection here in the future
  // if (content.includes('PrusaSlicer')) return 'PrusaSlicer';
  // if (content.includes('Cura')) return 'Cura';
  
  return null;
}

/**
 * Parse G-code file and extract consumption metadata
 */
export function parseGCode(content: string): ParsedGCode {
  const slicer = detectSlicer(content);
  
  if (!slicer) {
    return {
      success: false,
      metadata: {
        slicer: 'Unknown',
        usedFilamentM: null,
        usedFilamentG: null,
        printTime: null,
        materialType: null,
        color: null,
        modelName: null,
        layerCount: null,
        maxZHeight: null,
      },
      error: 'Unsupported slicer. Currently supported: Anycubic Slicer Next',
    };
  }

  switch (slicer) {
    case 'AnycubicSlicerNext':
      return parseAnycubicSlicerNext(content);
    default:
      return {
        success: false,
        metadata: {
          slicer,
          usedFilamentM: null,
          usedFilamentG: null,
          printTime: null,
          materialType: null,
          color: null,
          modelName: null,
          layerCount: null,
          maxZHeight: null,
        },
        error: `Parser not implemented for slicer: ${slicer}`,
      };
  }
}

